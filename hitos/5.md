# HITO 5
En este hito se ha desplegado la aplicación, se monitoriza el despliegue con grafana, y se ha probado el rendimiento del despliegue.

URLs (importante leer la siguiente sección antes de acceder a la app)
- https://sars-app.onrender.com/
- https://sarsapp.grafana.net/d/spring_boot_211

## Despliegue: render.com
Render.com es un IaaS. Lo he elegido sobre otras plataformas como heroku, ditigalocean, Fly.io, Koyeb, clever cloud y otras por los siguientes motivos:

- Su plan gratuito es el mejor. Permite tener la aplicación levantada 24/7, y el hardware cumple los requisitos mínimos para spring-boot. Rechacé la mayoría de las opciones por falta de RAM, sólo render pfrece 512MB gratuitamente. El servicio tiene la desventaja de que si no se usa la app 15 minutos seguidos, se apaga, y en el siguiente acceso hay que esperar a que despierte. Suele tardar dos minutos.
- Servidores en Fráncfort. No sólo permite elegir el servidor de la BD, como otros servicios, también el de la aplicación.
- Plataforma defininda en archivo de texto plano.
- Integración perfecta y sencilla con github.

La plataforma se encuentra definida en el archivo [render.yaml](/render.yaml).
Cada vez que se hace un push, se reconstruye y se vuelve a desplegar la aplicación
![dos contenedores](/hitos/recursos/5/deploys.png)

Una limitación común a todos los PaaS que he encontrado es que no permiten acceder directamente al demonio docker. Esto significa que mi contenedor de fluent-bit ya no se puede usar. No se pierde mucho, ya que render gestiona él mismo los logs.

Aquí se ven los dos servicios desplegados en render y cómo están en la unión europea.
![dos contenedores](/hitos/recursos/5/render.png)

### Configuración del despliegue

Configurar render es muy sencillo. Solo hay que meterse en la web, crear una cuenta, vincular github, + New > Blueprint y seleccionar el repositorio.

Para que funcione tenemos que tener [render.yaml](/render.yaml) en la raíz del repositorio. Paso a Analizar su estructura.

Se divide en dos secciones:

- Services: Definimos la configuración del servidor de render (plan gratuito en Fráncfort), y que la aplicación se debe construir con docker y de qué manera. Además definimos las variables de entorno necesarias para que arranque la aplicación, y para que la aplicación mande bien las métricas a grafana. Usando fromDatabase, render coge los parámetros de la BD (v.gr. el hostname) y se los pasamos a spring-boot.

- Databases: Definimos la base de datos. Por defecto es postgres así que no he tenido que configurar más que el nombre y la configuración del servidor.

## Monitorización

###OpenTelemetry
Lo primero que he hecho ha sido añadir y configurar OpenTelemetry en mi aplicación para que mande las métricas a grafana. Las métricas se exponen en /actuator/metrics

###Grafana
He creado una cuenta gratuita de grafana.
Los datos de grafana también están en Europa. Esto no es importante ya que los datos no sufren ninguna restricción legal, pero bueno, ya que tenía la opción...
![grafana](/hitos/recursos/5/graf1.png)

Para configurarlo todo, he obtenido las credenciales de OpenTelemetry de mi cuenta de grafana. OpenTelemetry se ha asociado automáticamente con una fuente de datos prometheus, de donde graphana muestra los datos.
Después he importado un dashboard de spring-boot. He tenido que configurar algunos campos por imcompatibilidad de nombres de variables, pero nada más. El enlace al dashboard está al principio del documento.
![grafana](/hitos/recursos/5/grafana.png)

## Rendimiento

Para finalizar, he hecho un análisis del rendimiento de la aplicación con el script [stress.py](/stress.py), que usa la librería aiohttp para hacer peticiones a la página.

![rend1](/hitos/recursos/5/rend1.png)
![rend2](/hitos/recursos/5/rend2.png)

El rendimiento no es excelente. El tiempo medio de respuesta es de ~40 ms. Vemos que no soporta demasiadas peticiones concurrentes. Le cuesta mucho servir más de 25 peticiones por segundo. 
![test1](/hitos/recursos/5/20.png)
![test2](/hitos/recursos/5/100.png)
![test3](/hitos/recursos/5/200.png)

Podemos ver el impacto del test usando grafana. 100% de cpu.
![rendimiento en grafana](/hitos/recursos/5/grafanarend.png)

