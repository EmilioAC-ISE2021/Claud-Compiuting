# Hito 2: Integración continua

## Tecnologías para el proyecto
He decidido que para la aplicación voy a usar spring, Thymeleaf como gestor de plantillas, y H2 para la base de datos. 

He considerado adecuado hacer una aplicación spring ya que se seguirá la metodología de desarrollo ágil. Sping-boot configura todo por ti, lo que permite centrarse en programar.
Además, spring está pensado para que sea muy fácil desplegar la aplicación (generas un .jar y basta con hacer "java app.jar"). Todo lo necesario para ejecutar la aplicación está en el .jar, es ideal para desplegar aplicaciones web.

De todas los sistemas de gestión de plantillas que he usado, thymeleaf es por lejos el mejor y el más simple, así que lo voy a usar para este proyecto. Además, su sistema de seguridad es también muy bueno. (Con seguridad me refiero a autenticación de usuarios y demás)

Por ahora voy a usar una base de datos H2. Es una base de datos embebida, por lo que forma parte del proceso de la aplicación y va dentro del .jar. Su desempeño no es el mejor, pero es ideal para hacer pruebas mientras se desarrolla la aplicación. Quizá la cambie por una BD mejor cuando acabe de desarrollar SARS, aunque por el tamaño de la operación no se notará ninguna diferencia.


Esto significa que voy a usar java, así que tengo que usar herramientas para java. Además, es interesante usar herramientas que estén bien integradas con spring:

## Tecnologías para el integración continua
-Gestor de tareas. Spring recomienda usar Maven o Gradle. Me he decantado por maven por dos razones. 1, es más simple que gradle. 2, para este proyecto no necesito nada que tenga gradle pero maven no. 3, la integración con spring es mejor (por ejemplo la documentación asume que usas maven). La única ventaja de gradle es que es más rápido, pero como la aplicación es tan pequeña nunca se va a notar. Maven y gradle son las dos opciones más usadas con muchísima diferencia en el mundo java. Usar otra sería tontería.

-Biblioteca de aserciones. Como nunca he usado una biblioteca de aserciones, voy a usar la que usa spring por defecto, AssertJ. Las otras bibliotecas que he considerado han sido JUnit Assertions y Hamcrest. AssertJ es la más potente y la más usada hoy en día.

-Test runner. De nuevo, voy a usar la herramienta por defecto de spring, JUnit 5. Es usada en el 80% de los proyectos en java, según JetBrains. Una de sus ventajas es que permite la ejecución de tests en paralelo. Maven llama a JUnit 5 usando el módulo Maven  Surefire.

Como he elegido Spring, no hace falta configurar estos tres elementos; se configuran solos. Esto garantiza que la configuración sea correcta.

-Integración continua. Usaré github actions. Considero que ya que estamos usando github, lo mejor es usar los sistemas que proporciona github, para minimizar posibles fallos de incompatibilidad y errores. Cuantas menos piezas tenga el sistema, hay menos posibles puntos de fallo.
He configurado el gitub actions [aquí](/.github/workflows/build.yml)

Una cosa a comentar es que he hecho que guarde los paquetes necesarios para ejecutar la aplicación en caché, para que tarde menos en pasar los tests. 

## Tests de lógica de negocio
He implementado 5 tests de la lógica de negocio:

-Probar que se puede crear una serie<br>
-« que no se puede crear una serie si ya existe<br>
-« que se puede crear un capítulo<br>
-« que se puede modificar el estado de una tarea<br>
-« que se puede modificar el usuario asignado a una tarea<br>

También he hecho pushes al repositorio, verificando que los tests se ejecutan, y pasan.
