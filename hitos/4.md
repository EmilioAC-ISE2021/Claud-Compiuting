# HITO 4
En este hito se han llevado la base de datos, los logs, y la aplicación a contenedores de docker, y se ha creado una composición de contenedores para poder levantar la aplicación fácilmente.

## Estructura del clúster de contenedores
Tenemos tres contenedores. Primero está el contenedor con la aplicación. Luego, el contenedor con la base de datos. Finalmente, el contenedor que se encarga de los logs de la aplicación. Los puertos están configurados para que los contenedores puedan comunicarse, y los puertos de la aplicación están mapeados para que podamos acceder a ella.
La estructura se encuentra definida en el archivo [docker-compose](/docker-compose.yml).

## Cada uno de los contenedores que componen el clúster de contenedores
Tenemos tres contenedores:<br><br>
1- Contenedor de la aplicación. Como tenemos una aplicación Spring Boot, lo único que necesitamos para ejecutar es un entorno de java (en este caso la versión 17), y para compilar necesitamos el jdk y la herramienta maven.
Usamos como contenedor base eclipse-temurin:17-jre, que a su vez se basa en ubuntu. Eclipse temurin es un java runtime enviroment, y lo hemos elegido por ser robusto, moderno y eficiente.
Para compilar hemos usado maven:3.8.7-eclipse-temurin-17, por las mismas razones.

2- Contenedor de la base de datos. He usado el contenedor base de PostgreSQL. Para mi aplicación lo más adecuado es una base de datos SQL, y PostgreSQL es la más recomendada hoy en día. He usado el contenedor por defecto, porque no necesito nada especial, y la configuración por defecto es lo suficientemente segura y eficiente.

3- Contenedor de logs  He usado el contenedor por defecto de Fluent Bit. Fluent Bit es una versión ligera de Fluentd, perfectamente integrada con docker, con un rendimiento excelente, y muy extensible. Además, permite integrarse con mi aplicación directamente, sin hacer ningún cambio. De nuevo, como no necesito configurar nada, he usado la imagen por defecto.
Para ver los logs tenemos que ejecutar esta linea desde la carpeta donde hacemos el docker-compose up: docker-compose logs fluent-bit. Se puede usar la flag -f para ver cómo llegan nuevos logs en tiempo real.

## Documentación de la actualización automática
He [configurado](/.github/workflows/build.yml) github actions para que cada vez que se haga un push se vuelva a generar el contenedor y a pasar los tests. No sé qué más comentar sobre esto.<br>
![pruebaActions](/hitos/recursos/4/package.png)

## Documentación de los Dockerfile
El [docker](/Dockerfile) primero compila la aplicación a un .jar, usando la imagen de maven, y luego la ejecuta usando la imagen del jre. Es importante mencionar que, como el dockerfile no vive en la carpeta del proyecto, sino en la superior, hay que indicarle en qué carpeta tiene que trabajar. Esto se hace desde [el fichero donde se configura lo de github actions](/.github/workflows/build.yml).

## Documentación del fichero de composición del clúster de contenedores
Tenemos cuatro servicios en el [docker-compose](/docker-compose.yml). El de la base de datos, el de la aplicación, el de los logs, y el que pasa los tests de la lógica de negocio de la aplicación al compilarla. El servicio de la app no puede empezar hasta que el servicio de la base de datos está operativo, y hasta que los tests han pasado.
<br><br>

Por último, aquí tenemos una foto de cómo pasan los tests de la aplicación, capturando los logs que generan los tests
![logs](/hitos/recursos/4/logs.png)
